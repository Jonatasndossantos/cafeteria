import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { mockFormData } from './mockDataEsp4';
import { useState } from 'react';

export interface Risk {
  id: number;
  evento: string;
  dano: string;
  impacto: string;
  probabilidade: string;
  acao_preventiva: string;
  responsavel_preventiva: string;
  acao_contingencia: string;
  responsavel_contingencia: string;
}

export interface FormData {
  identificacao: {
    numeroMatriz: string;
    numeroTR: string;
    numeroETP: string;
    objeto: string;
    status: string;
  };
  introducao: {
    objetivo: string;
    metodologia: string;
  };
  matrizRiscos: {
    riscos: Risk[];
  };
  garantias?: {
    valorContrato: string;
    percentualGarantia: string;
    valorGarantia: number;
  };
}

// Simula delay de API
const simulateApiDelay = (data: any, delay = 300): Promise<any> => {
  return new Promise(resolve => setTimeout(() => resolve(data), delay));
};

export const useFormData = () => {
  const queryClient = useQueryClient();

  // Query para buscar dados do formulário
  const { data, isLoading, error } = useQuery({
    queryKey: ['formData'],
    queryFn: () => simulateApiDelay(mockFormData),
    staleTime: 5 * 60 * 1000, // 5 minutos
    gcTime: 10 * 60 * 1000, // 10 minutos
  });

  // Mutation para salvar dados
  const saveMutation = useMutation({
    mutationFn: (newData: Partial<FormData>) => 
      simulateApiDelay({ ...data, ...newData }, 500),
    onSuccess: (updatedData) => {
      queryClient.setQueryData(['formData'], updatedData);
    },
  });

  // Mutation para salvar automaticamente (debounced)
  const autoSaveMutation = useMutation({
    mutationFn: (newData: Partial<FormData>) => 
      simulateApiDelay({ ...data, ...newData }, 100),
    onSuccess: (updatedData) => {
      queryClient.setQueryData(['formData'], updatedData);
    },
  });

  // Função para atualizar campo específico
  const updateField = (path: string, value: any) => {
    if (!data) return;

    const keys = path.split('.');
    const updatedData = { ...data };
    let current: any = updatedData;

    // Navega até o penúltimo nível
    for (let i = 0; i < keys.length - 1; i++) {
      if (current[keys[i]] === undefined) {
        current[keys[i]] = {};
      }
      current = current[keys[i]];
    }

    // Define o valor final
    current[keys[keys.length - 1]] = value;

    // Auto-save com debounce
    autoSaveMutation.mutate(updatedData);
  };

  // Função para salvar formulário completo
  const saveForm = () => {
    if (data) {
      saveMutation.mutate(data);
    }
  };

  // === FUNCIONALIDADES DE MATRIZ DE RISCOS ===

  // Estado para controle de geração de riscos
  const [isGeneratingRisks, setIsGeneratingRisks] = useState(false);

  // Função para adicionar novo risco
  const addRisk = () => {
    if (!data) return;

    const newRisk: Risk = {
      id: Date.now(), // Usar timestamp como ID único
      evento: '',
      dano: '',
      impacto: '',
      probabilidade: '',
      acao_preventiva: '',
      responsavel_preventiva: '',
      acao_contingencia: '',
      responsavel_contingencia: ''
    };
    
    const updatedRisks = [...data.matrizRiscos.riscos, newRisk];
    updateField('matrizRiscos.riscos', updatedRisks);
  };

  // Função para atualizar risco específico
  const updateRisk = (riskId: number, field: keyof Risk, value: string) => {
    if (!data) return;

    const updatedRisks = data.matrizRiscos.riscos.map((risk: Risk) => 
      risk.id === riskId ? { ...risk, [field]: value } : risk
    );
    updateField('matrizRiscos.riscos', updatedRisks);
  };

  // Função para remover risco
  const removeRisk = (riskId: number) => {
    if (!data) return;

    const updatedRisks = data.matrizRiscos.riscos.filter((risk: Risk) => risk.id !== riskId);
    updateField('matrizRiscos.riscos', updatedRisks);
  };

  // Função para gerar matriz de riscos automaticamente
  const generateRiskMatrix = async (guaranteeRequired: string, insuranceRequired: string) => {
    if (!data) return;
    
    setIsGeneratingRisks(true);
    
    // Simulação da IA LUX gerando riscos baseados no tipo de objeto e contexto
    const autoGeneratedRisks: Risk[] = mockFormData.matrizRiscos.riscos;

    // Simular delay da API
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    updateField('matrizRiscos.riscos', autoGeneratedRisks);
    setIsGeneratingRisks(false);
  };

  // Função para atualizar riscos baseado em mudanças de garantias/seguros
  const updateRisksBasedOnChanges = (guaranteeRequired: string, insuranceRequired: string) => {
    // Atualizar riscos automaticamente quando garantias/seguros mudarem
    generateRiskMatrix(guaranteeRequired, insuranceRequired);
  };

  return {
    // Dados e estado geral
    data: data as FormData,
    isLoading,
    error,
    updateField,
    saveForm,
    isSaving: saveMutation.isPending,
    isAutoSaving: autoSaveMutation.isPending,
    saveError: saveMutation.error,
    
    // Funcionalidades de matriz de riscos
    risks: data?.matrizRiscos?.riscos || [],
    addRisk,
    updateRisk,
    removeRisk,
    generateRiskMatrix,
    updateRisksBasedOnChanges,
    isGeneratingRisks,
  };
};
